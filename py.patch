--- ra25tst.py	2020-09-07 22:58:11.000000000 -0700
+++ ra25.py	2020-09-08 00:19:24.000000000 -0700
@@ -266,8 +328,8 @@
         full = prjn.NewFull()
 
         net.ConnectLayers(inp, hid1, full, emer.Forward)
-        net.BidirConnectLayers(hid1, hid2, full)
-        net.BidirConnectLayers(hid2, out, full)
+        net.BidirConnectLayersPy(hid1, hid2, full)
+        net.BidirConnectLayersPy(hid2, out, full)
 
         # note: can set these to do parallel threaded computation across multiple cpus
         # not worth it for this small of a model, but definitely helps for larger ones
@@ -283,10 +345,7 @@
 
         net.Defaults()
         ss.SetParams("Network", ss.LogSetParams) # only set Network params
-        err = net.Build()
-        if err != nil:
-            log.Println(err)
-            return
+        net.Build()
         net.InitWts()
 
     def Init(ss):
@@ -311,7 +370,7 @@
         NewRndSeed gets a new random seed based on current time -- otherwise uses
         the same random seed for every run
         """
-        ss.RndSeed = time.Now().UnixNano()
+        ss.RndSeed = datetime.now(timezone.utc)
 
     def Counters(ss, train):
         """
@@ -325,30 +384,30 @@
             return "Run:\t%d\tEpoch:\t%d\tTrial:\t%d\tCycle:\t%d\tName:\t%s\t\t\t" % (ss.TrainEnv.Run.Cur, ss.TrainEnv.Epoch.Cur, ss.TestEnv.Trial.Cur, ss.Time.Cycle, ss.TestEnv.TrialName.Cur)
 
     def UpdateView(ss, train):
-        if ss.NetView != nil and ss.NetView.IsVisible():
+        if ss.NetView != 0 and ss.NetView.IsVisible():
             ss.NetView.Record(ss.Counters(train))
 
             ss.NetView.GoUpdate()
 
     def AlphaCyc(ss, train):
         """
-        AlphaCyc runs one alpha-cycle (100 msec, 4 quarters)             of processing.
-        # ss.Win.PollEvents() // this can be used instead of running in a separate goroutine
+        AlphaCyc runs one alpha-cycle (100 msec, 4 quarters) of processing.
         External inputs must have already been applied prior to calling,
         using ApplyExt method on relevant layers (see TrainTrial, TestTrial).
-
-        # update prior weight changes at start, so any DWt values remain visible at end
-        # you might want to do this less frequently to achieve a mini-batch update
-        # in which case, move it out to the TrainTrial method where the relevant
-        # counters are being dealt with.
         If train is true, then learning DWt or WtFmDWt calls are made.
         Handles netview updating within scope of AlphaCycle
         """
 
+        if ss.Win != 0:
+            ss.Win.PollEvents() # this is essential for GUI responsiveness while running
         viewUpdt = ss.TrainUpdt
         if not train:
             viewUpdt = ss.TestUpdt
 
+        # update prior weight changes at start, so any DWt values remain visible at end
+        # you might want to do this less frequently to achieve a mini-batch update
+        # in which case, move it out to the TrainTrial method where the relevant
+        # counters are being dealt with.
         if train:
             ss.Net.WtFmDWt()
 
@@ -361,17 +420,15 @@
                     ss.LogTstCyc(ss.TstCycLog, ss.Time.Cycle)
                 ss.Time.CycleInc()
                 if ss.ViewOn:
-                    switch viewUpdt:
-                    if leabra.Cycle:
+                    if viewUpdt == leabra.Cycle:
                         if cyc != ss.Time.CycPerQtr-1: # will be updated by quarter
                             ss.UpdateView(train)
-                    if leabra.FastSpike:
+                    if viewUpdt == leabra.FastSpike:
                         if (cyc+1)%10 == 0:
                             ss.UpdateView(train)
             ss.Net.QuarterFinal(ss.Time)
             ss.Time.QuarterInc()
             if ss.ViewOn:
-                switch :
                 if viewUpdt <= leabra.Quarter:
                     ss.UpdateView(train)
                 if viewUpdt == leabra.Phase:
@@ -382,7 +439,7 @@
             ss.Net.DWt()
         if ss.ViewOn and viewUpdt == leabra.AlphaCycle:
             ss.UpdateView(train)
-        if not train:
+        if ss.TstCycPlot != 0 and not train:
             ss.TstCycPlot.GoUpdate() # make sure up-to-date at end
 
 
@@ -394,11 +451,11 @@
         (training, testing, etc).
         """
 
-        lays = go.Slice_string(["Input", "Output"])
-        for _, lnm in lays :
-            ly = leabra.LeabraLayer(ss.Net.LayerByName(lnm)).AsLeabra()
+        lays = ["Input", "Output"]
+        for lnm in lays :
+            ly = leabra.Layer(ss.Net.LayerByName(lnm))
             pats = en.State(ly.Nm)
-            if pats != nil:
+            if pats != 0:
                 ly.ApplyExt(pats)
 
     def TrainTrial(ss):
@@ -412,7 +469,9 @@
 
         # Key to query counters FIRST because current state is in NEXT epoch
         # if epoch counter has changed
-        epc, _, chg = ss.TrainEnv.Counter(env.Epoch)
+        epc = env.CounterCur(ss.TrainEnv, env.Epoch)
+        chg = env.CounterChg(ss.TrainEnv, env.Epoch)
+
         if chg:
             ss.LogTrnEpc(ss.TrnEpcLog)
             if ss.ViewOn and ss.TrainUpdt > leabra.AlphaCycle:
@@ -487,9 +546,10 @@
         different time-scales over which stats could be accumulated etc.
         You can also aggregate directly from log data, as is done for testing stats
         """
-        out = leabra.LeabraLayer(ss.Net.LayerByName("Output")).AsLeabra()
+        out = leabra.Layer(ss.Net.LayerByName("Output"))
         ss.TrlCosDiff = float(out.CosDiff.Cos)
-        ss.TrlSSE, ss.TrlAvgSSE = out.MSE(0.5)
+        ss.TrlSSE = out.SSE(0.5) # 0.5 = per-unit tolerance -- right side of .5
+        ss.TrlAvgSSE = ss.TrlSSE / len(out.Neurons)
         if ss.TrlSSE > 0:
             ss.TrlErr = 1
         else:
@@ -546,11 +606,12 @@
         Stopped is called when a run method stops running -- updates the IsRunning flag and toolbar
         """
         ss.IsRunning = False
-        if ss.Win != nil:
+        if ss.Win != 0:
             vp = ss.Win.WinViewport2D()
-            if ss.ToolBar != nil:
+            if ss.ToolBar != 0:
                 ss.ToolBar.UpdateActions()
             vp.SetNeedsFullRender()
+            ss.ClassView.Update()
 
     def SaveWeights(ss, filename):
         """
@@ -565,7 +626,7 @@
         """
         ss.TestEnv.Step()
 
-        _, _, chg = ss.TestEnv.Counter(env.Epoch)
+        chg = env.CounterChg(ss.TestEnv, env.Epoch)
         if chg:
             if ss.ViewOn and ss.TestUpdt > leabra.AlphaCycle:
                 ss.UpdateView(False)
@@ -597,7 +658,7 @@
         ss.TestEnv.Init(ss.TrainEnv.Run.Cur)
         while True:
             ss.TestTrial(True)
-            _, _, chg = ss.TestEnv.Counter(env.Epoch)
+            chg = env.CounterChg(ss.TestEnv, env.Epoch)
             if chg or ss.StopNow:
                 break
 
@@ -627,12 +688,11 @@
         if sheet == "":
 
             ss.Params.ValidateSheets(go.Slice_string(["Network", "Sim"]))
-        err = ss.SetParamsSet("Base", sheet, setMsg)
+        ss.SetParamsSet("Base", sheet, setMsg)
         if ss.ParamSet != "" and ss.ParamSet != "Base":
-            sps = strings.Fields(ss.ParamSet)
-            for _, ps in sps :
-                err = ss.SetParamsSet(ps, sheet, setMsg)
-        return err
+            sps = ss.ParamSet.split()
+            for ps in sps:
+                ss.SetParamsSet(ps, sheet, setMsg)
 
     def SetParamsSet(ss, setNm, sheet, setMsg):
         """
@@ -641,30 +701,26 @@
         otherwise just the named sheet
         if setMsg = true then we output a message for each param that was set.
         """
-        pset, err = ss.Params.SetByNameTry(setNm)
-        if err != nil:
-            return err
+        pset = ss.Params.SetByNameTry(setNm)
         if sheet == "" or sheet == "Network":
-            netp, ok = pset.Sheets["Network"]
-            if ok:
+            if "Network" in pset.Sheets:
+                netp = pset.SheetByNameTry("Network")
                 ss.Net.ApplyParams(netp, setMsg)
 
         if sheet == "" or sheet == "Sim":
-            simp, ok = pset.Sheets["Sim"]
-            if ok:
-                simp.Apply(ss, setMsg)
-
-        return err
+            if "Sim" in pset.Sheets:
+                simp= pset.SheetByNameTry("Sim")
+                epygiv.ApplyParams(ss, simp, setMsg)
 
     def ConfigPats(ss):
         dt = ss.Pats
         dt.SetMetaData("name", "TrainPats")
         dt.SetMetaData("desc", "Training patterns")
-        dt.SetFromSchema(etable.Schema(
-            ("Name", etensor.STRING, nil, nil),
-            ("Input", etensor.FLOAT32, []int(5, 5]), go.Slice_string(["Y", "X")),
-            ("Output", etensor.FLOAT32, []int(5, 5]), go.Slice_string(["Y", "X")),
-        ), 25)
+        sc = etable.Schema()
+        sc.append(etable.Column("Name", etensor.STRING, nilInts, nilStrs))
+        sc.append(etable.Column("Input", etensor.FLOAT32, go.Slice_int([5, 5]), go.Slice_string(["Y", "X"])))
+        sc.append(etable.Column("Output", etensor.FLOAT32, go.Slice_int([5, 5]), go.Slice_string(["Y", "X"])))
+        dt.SetFromSchema(sc, 25)
 
         patgen.PermutedBinaryRows(dt.Cols[1], 6, 1, 0)
         patgen.PermutedBinaryRows(dt.Cols[2], 6, 1, 0)
@@ -674,20 +730,16 @@
         dt = ss.Pats
         dt.SetMetaData("name", "TrainPats")
         dt.SetMetaData("desc", "Training patterns")
-        err = dt.OpenCSV("random_5x5_25.tsv", etable.Tab)
-        if err != nil:
-            log.Println(err)
+        dt.OpenCSV("random_5x5_25.tsv", etable.Tab)
 
     def ValsTsr(ss, name):
         """
         ValsTsr gets value tensor of given name, creating if not yet made
         """
-        if ss.ValsTsrs == nil:
-            ss.ValsTsrs = make(map[string]*etensor.Float32)
-        tsr, ok = ss.ValsTsrs[name]
-        if not ok:
-            tsr = etensor.Float32()
-            ss.ValsTsrs[name] = tsr
+        if name in ss.ValsTsrs:
+            return ss.ValsTsrs[name]
+        tsr = etensor.Float32()
+        ss.ValsTsrs[name] = tsr
         return tsr
 
     def RunName(ss):
@@ -746,12 +798,12 @@
         else:
             ss.NZero = 0
 
-        if ss.LastEpcTime.IsZero():
-            ss.EpcPerTrlMSec = 0
-        else:
-            iv = time.Now().Sub(ss.LastEpcTime)
-            ss.EpcPerTrlMSec = float(iv) / (nt * float(time.Millisecond))
-        ss.LastEpcTime = time.Now()
+        # if ss.LastEpcTime.IsZero():
+        #     ss.EpcPerTrlMSec = 0
+        # else:
+        #     iv = time.Now().Sub(ss.LastEpcTime)
+        #     ss.EpcPerTrlMSec = float(iv) / (nt * float(time.Millisecond))
+        # ss.LastEpcTime = time.Now()
 
         dt.SetCellFloat("Run", row, float(ss.TrainEnv.Run.Cur))
         dt.SetCellFloat("Epoch", row, float(epc))
@@ -760,14 +812,15 @@
         dt.SetCellFloat("PctErr", row, ss.EpcPctErr)
         dt.SetCellFloat("PctCor", row, ss.EpcPctCor)
         dt.SetCellFloat("CosDiff", row, ss.EpcCosDiff)
-        dt.SetCellFloat("PerTrlMSec", row, ss.EpcPerTrlMSec)
+        # dt.SetCellFloat("PerTrlMSec", row, ss.EpcPerTrlMSec)
 
-        for _, lnm in ss.LayStatNms :
-            ly = leabra.LeabraLayer(ss.Net.LayerByName(lnm)).AsLeabra()
-            dt.SetCellFloat(ly.Nm+"_ActAvg", row, float(ly.Pools[0].ActAvg.ActPAvgEff))
-
-        ss.TrnEpcPlot.GoUpdate()
-        if ss.TrnEpcFile != nil:
+        for lnm in ss.LayStatNms:
+            ly = leabra.Layer(ss.Net.LayerByName(lnm))
+            dt.SetCellFloat(ly.Nm+"_ActAvg", row, float(ly.Pool(0).ActAvg.ActPAvgEff))
+
+        if ss.TrnEpcPlot != 0:
+            ss.TrnEpcPlot.GoUpdate()
+        if ss.TrnEpcFile != 0:
             if ss.TrainEnv.Run.Cur == 0 and epc == 0:
                 dt.WriteCSVHeaders(ss.TrnEpcFile, etable.Tab)
             dt.WriteCSVRow(ss.TrnEpcFile, row, etable.Tab)
@@ -778,19 +831,18 @@
         dt.SetMetaData("read-only", "true")
         dt.SetMetaData("precision", str(LogPrec))
 
-        sch = etable.Schema(
-            ("Run", etensor.INT64, nil, nil),
-            ("Epoch", etensor.INT64, nil, nil),
-            ("SSE", etensor.FLOAT64, nil, nil),
-            ("AvgSSE", etensor.FLOAT64, nil, nil),
-            ("PctErr", etensor.FLOAT64, nil, nil),
-            ("PctCor", etensor.FLOAT64, nil, nil),
-            ("CosDiff", etensor.FLOAT64, nil, nil),
-            ("PerTrlMSec", etensor.FLOAT64, nil, nil),
-        )
-        for _, lnm in ss.LayStatNms :
-       .append( etable.Column(lnm + "_ActAvg", etensor.FLOAT64, nil, nil))
-        dt.SetFromSchema(sch, 0)
+        sc = etable.Schema()
+        sc.append(etable.Column("Run", etensor.INT64, nilInts, nilStrs))
+        sc.append(etable.Column("Epoch", etensor.INT64, nilInts, nilStrs))
+        sc.append(etable.Column("SSE", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("AvgSSE", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("PctErr", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("PctCor", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("CosDiff", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("PerTrlMSec", etensor.FLOAT64, nilInts, nilStrs))
+        for lnm in ss.LayStatNms:
+            sc.append(etable.Column(lnm + "_ActAvg", etensor.FLOAT64, nilInts, nilStrs))
+        dt.SetFromSchema(sc, 0)
 
     def ConfigTrnEpcPlot(ss, plt, dt):
         plt.Params.Title = "Leabra Random Associator 25 Epoch Plot"
@@ -806,7 +858,7 @@
         plt.SetColParams("CosDiff", eplot.Off, eplot.FixMin, 0, eplot.FixMax, 1)
         plt.SetColParams("PerTrlMSec", eplot.Off, eplot.FixMin, 0, eplot.FloatMax, 0)
 
-        for _, lnm in ss.LayStatNms :
+        for lnm in ss.LayStatNms:
             plt.SetColParams(lnm+"_ActAvg", eplot.Off, eplot.FixMin, 0, eplot.FixMax, .5)
         return plt
 
@@ -816,8 +868,8 @@
         log always contains number of testing items
         """
         epc = ss.TrainEnv.Epoch.Prv
-        inp = leabra.LeabraLayer(ss.Net.LayerByName("Input")).AsLeabra()
-        out = leabra.LeabraLayer(ss.Net.LayerByName("Output")).AsLeabra()
+        inp = leabra.Layer(ss.Net.LayerByName("Input"))
+        out = leabra.Layer(ss.Net.LayerByName("Output"))
 
         trl = ss.TestEnv.Trial.Cur
         row = trl
@@ -834,9 +886,9 @@
         dt.SetCellFloat("AvgSSE", row, ss.TrlAvgSSE)
         dt.SetCellFloat("CosDiff", row, ss.TrlCosDiff)
 
-        for _, lnm in ss.LayStatNms :
-            ly = leabra.LeabraLayer(ss.Net.LayerByName(lnm)).AsLeabra()
-            dt.SetCellFloat(ly.Nm+" ActM.Avg", row, float(ly.Pools[0].ActM.Avg))
+        for lnm in ss.LayStatNms:
+            ly = leabra.Layer(ss.Net.LayerByName(lnm))
+            dt.SetCellFloat(ly.Nm+" ActM.Avg", row, float(ly.Pool(0).ActM.Avg))
         ivt = ss.ValsTsr("Input")
         ovt = ss.ValsTsr("Output")
         inp.UnitValsTensor(ivt, "Act")
@@ -846,11 +898,12 @@
         out.UnitValsTensor(ovt, "ActP")
         dt.SetCellTensor("OutActP", row, ovt)
 
-        ss.TstTrlPlot.GoUpdate()
+        if ss.TstTrlPlot != 0:
+            ss.TstTrlPlot.GoUpdate()
 
     def ConfigTstTrlLog(ss, dt):
-        inp = leabra.LeabraLayer(ss.Net.LayerByName("Input")).AsLeabra()
-        out = leabra.LeabraLayer(ss.Net.LayerByName("Output")).AsLeabra()
+        inp = leabra.Layer(ss.Net.LayerByName("Input"))
+        out = leabra.Layer(ss.Net.LayerByName("Output"))
 
         dt.SetMetaData("name", "TstTrlLog")
         dt.SetMetaData("desc", "Record of testing per input pattern")
@@ -858,24 +911,23 @@
         dt.SetMetaData("precision", str(LogPrec))
 
         nt = ss.TestEnv.Table.Len() # number in view
-        sch = etable.Schema(
-            ("Run", etensor.INT64, nil, nil),
-            ("Epoch", etensor.INT64, nil, nil),
-            ("Trial", etensor.INT64, nil, nil),
-            ("TrialName", etensor.STRING, nil, nil),
-            ("Err", etensor.FLOAT64, nil, nil),
-            ("SSE", etensor.FLOAT64, nil, nil),
-            ("AvgSSE", etensor.FLOAT64, nil, nil),
-            ("CosDiff", etensor.FLOAT64, nil, nil),
-        )
-        for _, lnm in ss.LayStatNms :
-       .append( etable.Column(lnm + " ActM.Avg", etensor.FLOAT64, nil, nil))
-      .append( etable.Schema(
-            ("InAct", etensor.FLOAT64, inp.Shp.Shp, nil),
-            ("OutActM", etensor.FLOAT64, out.Shp.Shp, nil),
-            ("OutActP", etensor.FLOAT64, out.Shp.Shp, nil),
-        )...)
-        dt.SetFromSchema(sch, nt)
+        sc = etable.Schema()
+        sc.append(etable.Column("Run", etensor.INT64, nilInts, nilStrs))
+        sc.append(etable.Column("Epoch", etensor.INT64, nilInts, nilStrs))
+        sc.append(etable.Column("Trial", etensor.INT64, nilInts, nilStrs))
+        sc.append(etable.Column("TrialName", etensor.STRING, nilInts, nilStrs))
+        sc.append(etable.Column("Err", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("SSE", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("AvgSSE", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("CosDiff", etensor.FLOAT64, nilInts, nilStrs))
+        
+        for lnm in ss.LayStatNms :
+            sc.append(etable.Column(lnm + " ActM.Avg", etensor.FLOAT64, nilInts, nilStrs))
+            
+        sc.append(etable.Column("InAct", etensor.FLOAT64, inp.Shp.Shp, nilStrs))
+        sc.append(etable.Column("OutActM", etensor.FLOAT64, out.Shp.Shp, nilStrs))
+        sc.append(etable.Column("OutActP", etensor.FLOAT64, out.Shp.Shp, nilStrs))
+        dt.SetFromSchema(sc, nt)
 
     def ConfigTstTrlPlot(ss, plt, dt):
         plt.Params.Title = "Leabra Random Associator 25 Test Trial Plot"
@@ -891,7 +943,7 @@
         plt.SetColParams("AvgSSE", eplot.On, eplot.FixMin, 0, eplot.FloatMax, 0)
         plt.SetColParams("CosDiff", eplot.On, eplot.FixMin, 0, eplot.FixMax, 1)
 
-        for _, lnm in ss.LayStatNms :
+        for lnm in ss.LayStatNms:
             plt.SetColParams(lnm+" ActM.Avg", eplot.Off, eplot.FixMin, 0, eplot.FixMax, .5)
 
         plt.SetColParams("InAct", eplot.Off, eplot.FixMin, 0, eplot.FixMax, 1)
@@ -918,8 +970,7 @@
         dt.SetCellFloat("CosDiff", row, agg.Mean(tix, "CosDiff")[0])
 
         trlix = etable.NewIdxView(trl)
-        trlix.Filter(funcet, row:
-            return et.CellFloat("SSE", row) > 0)# include error trials
+        trlix.Filter(FilterSSE) # requires separate function
 
         ss.TstErrLog = trlix.NewTable()
 
@@ -933,7 +984,8 @@
         ss.TstErrStats = allsp.AggsToTable(etable.AddAggName)
 
         # note: essential to use Go version of update when called from another goroutine
-        ss.TstEpcPlot.GoUpdate()
+        if ss.TstEpcPlot != 0:
+            ss.TstEpcPlot.GoUpdate()
 
     def ConfigTstEpcLog(ss, dt):
         dt.SetMetaData("name", "TstEpcLog")
@@ -941,15 +993,15 @@
         dt.SetMetaData("read-only", "true")
         dt.SetMetaData("precision", str(LogPrec))
 
-        dt.SetFromSchema(etable.Schema(
-            ("Run", etensor.INT64, nil, nil),
-            ("Epoch", etensor.INT64, nil, nil),
-            ("SSE", etensor.FLOAT64, nil, nil),
-            ("AvgSSE", etensor.FLOAT64, nil, nil),
-            ("PctErr", etensor.FLOAT64, nil, nil),
-            ("PctCor", etensor.FLOAT64, nil, nil),
-            ("CosDiff", etensor.FLOAT64, nil, nil),
-        ), 0)
+        sc = etable.Schema()
+        sc.append(etable.Column("Run", etensor.INT64, nilInts, nilStrs))
+        sc.append(etable.Column("Epoch", etensor.INT64, nilInts, nilStrs))
+        sc.append(etable.Column("SSE", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("AvgSSE", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("PctErr", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("PctCor", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("CosDiff", etensor.FLOAT64, nilInts, nilStrs))
+        dt.SetFromSchema(sc, 0)
 
     def ConfigTstEpcPlot(ss, plt, dt):
         plt.Params.Title = "Leabra Random Associator 25 Testing Epoch Plot"
@@ -974,12 +1026,12 @@
             dt.SetNumRows(cyc + 1)
 
         dt.SetCellFloat("Cycle", cyc, float(cyc))
-        for _, lnm in ss.LayStatNms :
-            ly = leabra.LeabraLayer(ss.Net.LayerByName(lnm)).AsLeabra()
-            dt.SetCellFloat(ly.Nm+" Ge.Avg", cyc, float(ly.Pools[0].Inhib.Ge.Avg))
-            dt.SetCellFloat(ly.Nm+" Act.Avg", cyc, float(ly.Pools[0].Inhib.Act.Avg))
+        for lnm in ss.LayStatNms:
+            ly = leabra.Layer(ss.Net.LayerByName(lnm))
+            dt.SetCellFloat(ly.Nm+" Ge.Avg", cyc,  float(ly.Pool(0).Inhib.Ge.Avg))
+            dt.SetCellFloat(ly.Nm+" Act.Avg", cyc, float(ly.Pool(0).Inhib.Act.Avg))
 
-        if cyc%10 == 0: # too slow to do every cyc
+        if ss.TstCycPlot != 0 and cyc%10 == 0: # too slow to do every cyc
             # note: essential to use Go version of update when called from another goroutine
             ss.TstCycPlot.GoUpdate()
 
@@ -990,13 +1042,13 @@
         dt.SetMetaData("precision", str(LogPrec))
 
         np = 100 # max cycles
-        sch = etable.Schema(
-            ("Cycle", etensor.INT64, nil, nil),
-        )
-        for _, lnm in ss.LayStatNms :
-       .append( etable.Column(lnm + " Ge.Avg", etensor.FLOAT64, nil, nil))
-       .append( etable.Column(lnm + " Act.Avg", etensor.FLOAT64, nil, nil))
-        dt.SetFromSchema(sch, np)
+        sc = etable.Schema()
+        sc.append(etable.Column("Cycle", etensor.INT64, nilInts, nilStrs))
+        
+        for lnm in ss.LayStatNms:
+            sc.append(etable.Column(lnm + " Ge.Avg", etensor.FLOAT64, nilInts, nilStrs))
+            sc.append(etable.Column(lnm + " Act.Avg", etensor.FLOAT64, nilInts, nilStrs))
+        dt.SetFromSchema(sc, np)
 
     def ConfigTstCycPlot(ss, plt, dt):
         plt.Params.Title = "Leabra Random Associator 25 Test Cycle Plot"
@@ -1004,7 +1056,7 @@
         plt.SetTable(dt)
         # order of params: on, fixMin, min, fixMax, max
         plt.SetColParams("Cycle", eplot.Off, eplot.FixMin, 0, eplot.FloatMax, 0)
-        for _, lnm in ss.LayStatNms :
+        for lnm in ss.LayStatNms:
             plt.SetColParams(lnm+" Ge.Avg", True, True, 0, True, .5)
             plt.SetColParams(lnm+" Act.Avg", True, True, 0, True, .5)
         return plt
@@ -1012,9 +1064,8 @@
     def LogRun(ss, dt):
         """
         LogRun adds data from current run to the RunLog table.
-        # this is NOT triggered by increment yet -- use Cur
         """
-        run = ss.TrainEnv.Run.Cur
+        run = ss.TrainEnv.Run.Cur # this is NOT triggered by increment yet -- use Cur
         row = dt.Rows
         dt.SetNumRows(row + 1)
 
@@ -1024,7 +1075,7 @@
         nlast = 5
         if nlast > epcix.Len()-1:
             nlast = epcix.Len() - 1
-        epcix.Idxs = epcix.Idxs[epcix.Len()-nlast:]
+        epcix.Idxs = go.Slice_int(epcix.Idxs[epcix.Len()-nlast:])
 
         params = ss.RunName() # includes tag
 
@@ -1044,8 +1095,9 @@
         ss.RunStats = spl.AggsToTable(etable.AddAggName)
 
         # note: essential to use Go version of update when called from another goroutine
-        ss.RunPlot.GoUpdate()
-        if ss.RunFile != nil:
+        if ss.RunPlot != 0:
+            ss.RunPlot.GoUpdate()
+        if ss.RunFile != 0:
             if row == 0:
                 dt.WriteCSVHeaders(ss.RunFile, etable.Tab)
             dt.WriteCSVRow(ss.RunFile, row, etable.Tab)
@@ -1056,16 +1108,16 @@
         dt.SetMetaData("read-only", "true")
         dt.SetMetaData("precision", str(LogPrec))
 
-        dt.SetFromSchema(etable.Schema(
-            ("Run", etensor.INT64, nil, nil),
-            ("Params", etensor.STRING, nil, nil),
-            ("FirstZero", etensor.FLOAT64, nil, nil),
-            ("SSE", etensor.FLOAT64, nil, nil),
-            ("AvgSSE", etensor.FLOAT64, nil, nil),
-            ("PctErr", etensor.FLOAT64, nil, nil),
-            ("PctCor", etensor.FLOAT64, nil, nil),
-            ("CosDiff", etensor.FLOAT64, nil, nil),
-        ), 0)
+        sc = etable.Schema()
+        sc.append(etable.Column("Run", etensor.INT64, nilInts, nilStrs))
+        sc.append(etable.Column("Params", etensor.STRING, nilInts, nilStrs))
+        sc.append(etable.Column("FirstZero", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("SSE", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("AvgSSE", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("PctErr", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("PctCor", etensor.FLOAT64, nilInts, nilStrs))
+        sc.append(etable.Column("CosDiff", etensor.FLOAT64, nilInts, nilStrs))
+        dt.SetFromSchema(sc, 0)
 
     def ConfigRunPlot(ss, plt, dt):
         plt.Params.Title = "Leabra Random Associator 25 Run Plot"
@@ -1089,12 +1141,13 @@
         height = 1200
 
         gi.SetAppName("ra25")
-        gi.SetAppAbout(`This demonstrates a basic Leabra model. See <a href="https://github.com/emer/emergent">emergent on GitHub</a>.</p>`)
+        gi.SetAppAbout('This demonstrates a basic Leabra model. See <a href="https://github.com/emer/emergent">emergent on GitHub</a>.</p>')
 
         win = gi.NewMainWindow("ra25", "Leabra Random Associator", width, height)
         ss.Win = win
 
         vp = win.WinViewport2D()
+        ss.vp = vp
         updt = vp.UpdateStart()
 
         mfr = win.SetMainFrame()
@@ -1107,12 +1160,14 @@
         split.Dim = mat32.X
         split.SetStretchMax()
 
-        sv = giv.AddNewStructView(split, "sv")
-        sv.SetStruct(ss)
+        ss.ClassView = epygiv.ClassView("ra25sv", ss.Tags)
+        ss.ClassView.AddFrame(split)
+        ss.ClassView.SetClass(ss)
 
         tv = gi.AddNewTabView(split, "tv")
 
-        nv = *netview.NetView(tv.AddNewTab(netview.KiT_NetView, "NetView"))
+        nv = netview.NetView()
+        tv.AddTab(nv, "NetView")
         nv.Var = "Act"
         # nv.Params.ColorMap = "Jet" // default is ColdHot
         # which fares pretty well in terms of discussion here:
@@ -1123,127 +1178,69 @@
         nv.Scene().Camera.Pose.Pos.Set(0, 1, 2.75) # more "head on" than default which is more "top down"
         nv.Scene().Camera.LookAt(mat32.Vec3(0, 0, 0), mat32.Vec3(0, 1, 0))
 
-        plt = *eplot.Plot2D(tv.AddNewTab(eplot.KiT_Plot2D, "TrnEpcPlot"))
+        plt = eplot.Plot2D()
+        tv.AddTab(plt, "TrnEpcPlot")
         ss.TrnEpcPlot = ss.ConfigTrnEpcPlot(plt, ss.TrnEpcLog)
 
-        plt = *eplot.Plot2D(tv.AddNewTab(eplot.KiT_Plot2D, "TstTrlPlot"))
+        plt = eplot.Plot2D()
+        tv.AddTab(plt, "TstTrlPlot")
         ss.TstTrlPlot = ss.ConfigTstTrlPlot(plt, ss.TstTrlLog)
 
-        plt = *eplot.Plot2D(tv.AddNewTab(eplot.KiT_Plot2D, "TstCycPlot"))
+        plt = eplot.Plot2D()
+        tv.AddTab(plt, "TstCycPlot")
         ss.TstCycPlot = ss.ConfigTstCycPlot(plt, ss.TstCycLog)
 
-        plt = *eplot.Plot2D(tv.AddNewTab(eplot.KiT_Plot2D, "TstEpcPlot"))
+        plt = eplot.Plot2D()
+        tv.AddTab(plt, "TstEpcPlot")
         ss.TstEpcPlot = ss.ConfigTstEpcPlot(plt, ss.TstEpcLog)
 
-        plt = *eplot.Plot2D(tv.AddNewTab(eplot.KiT_Plot2D, "RunPlot"))
+        plt = eplot.Plot2D()
+        tv.AddTab(plt, "RunPlot")
         ss.RunPlot = ss.ConfigRunPlot(plt, ss.RunLog)
 
-        split.SetSplits(.3, .7)
+        split.SetSplitsList(go.Slice_float32([.3, .7]))
 
-        tbar.AddAction(gi.ActOpts(Label= "Init", Icon= "update", Tooltip= "Initialize everything including network weights, and start over.  Also applies current params.", UpdateFunc= funcact:
-            act.SetActiveStateUpdt(not ss.IsRunning)), win.This(), funcrecv, send, sig, data:
-            ss.Init()
-            vp.SetNeedsFullRender())
-
-        tbar.AddAction(gi.ActOpts(Label= "Train", Icon= "run", Tooltip= "Starts the network training, picking up from wherever it may have left off.  If not stopped, training will complete the specified number of Runs through the full number of Epochs of training, with testing automatically occuring at the specified interval.",
-            UpdateFunc= funcact:
-                act.SetActiveStateUpdt(not ss.IsRunning)), win.This(), funcrecv, send, sig, data:
-            if not ss.IsRunning:
-                ss.IsRunning = True
-                tbar.UpdateActions()
-                # ss.Train()
-                go ss.Train())
-
-        tbar.AddAction(gi.ActOpts(Label= "Stop", Icon= "stop", Tooltip= "Interrupts running.  Hitting Train again will pick back up where it left off.", UpdateFunc= funcact:
-            act.SetActiveStateUpdt(ss.IsRunning)), win.This(), funcrecv, send, sig, data:
-            ss.Stop())
-
-        tbar.AddAction(gi.ActOpts(Label= "Step Trial", Icon= "step-fwd", Tooltip= "Advances one training trial at a time.", UpdateFunc= funcact:
-            act.SetActiveStateUpdt(not ss.IsRunning)), win.This(), funcrecv, send, sig, data:
-            if not ss.IsRunning:
-                ss.IsRunning = True
-                ss.TrainTrial()
-                ss.IsRunning = False
-                vp.SetNeedsFullRender())
-
-        tbar.AddAction(gi.ActOpts(Label= "Step Epoch", Icon= "fast-fwd", Tooltip= "Advances one epoch (complete set of training patterns) at a time.", UpdateFunc= funcact:
-            act.SetActiveStateUpdt(not ss.IsRunning)), win.This(), funcrecv, send, sig, data:
-            if not ss.IsRunning:
-                ss.IsRunning = True
-                tbar.UpdateActions()
-                go ss.TrainEpoch())
-
-        tbar.AddAction(gi.ActOpts(Label= "Step Run", Icon= "fast-fwd", Tooltip= "Advances one full training Run at a time.", UpdateFunc= funcact:
-            act.SetActiveStateUpdt(not ss.IsRunning)), win.This(), funcrecv, send, sig, data:
-            if not ss.IsRunning:
-                ss.IsRunning = True
-                tbar.UpdateActions()
-                go ss.TrainRun())
+        recv = win.This()
+        
+        tbar.AddAction(gi.ActOpts(Label="Init", Icon="update", Tooltip="Initialize everything including network weights, and start over.  Also applies current params.", UpdateFunc=UpdtFuncNotRunning), recv, InitCB)
+
+        tbar.AddAction(gi.ActOpts(Label="Train", Icon="run", Tooltip="Starts the network training, picking up from wherever it may have left off.  If not stopped, training will complete the specified number of Runs through the full number of Epochs of training, with testing automatically occuring at the specified interval.", UpdateFunc=UpdtFuncNotRunning), recv, TrainCB)
+        
+        tbar.AddAction(gi.ActOpts(Label="Stop", Icon="stop", Tooltip="Interrupts running.  Hitting Train again will pick back up where it left off.", UpdateFunc=UpdtFuncRunning), recv, StopCB)
+        
+        tbar.AddAction(gi.ActOpts(Label="Step Trial", Icon="step-fwd", Tooltip="Advances one training trial at a time.", UpdateFunc=UpdtFuncNotRunning), recv, StepTrialCB)
+        
+        tbar.AddAction(gi.ActOpts(Label="Step Epoch", Icon="fast-fwd", Tooltip="Advances one epoch (complete set of training patterns) at a time.", UpdateFunc=UpdtFuncNotRunning), recv, StepEpochCB)
 
+        tbar.AddAction(gi.ActOpts(Label="Step Run", Icon="fast-fwd", Tooltip="Advances one full training Run at a time.", UpdateFunc=UpdtFuncNotRunning), recv, StepRunCB)
+        
         tbar.AddSeparator("test")
-
-        tbar.AddAction(gi.ActOpts(Label= "Test Trial", Icon= "step-fwd", Tooltip= "Runs the next testing trial.", UpdateFunc= funcact:
-            act.SetActiveStateUpdt(not ss.IsRunning)), win.This(), funcrecv, send, sig, data:
-            if not ss.IsRunning:
-                ss.IsRunning = True
-                ss.TestTrial(False) # don't return on change -- wrap
-                ss.IsRunning = False
-                vp.SetNeedsFullRender())
-
-        tbar.AddAction(gi.ActOpts(Label= "Test Item", Icon= "step-fwd", Tooltip= "Prompts for a specific input pattern name to run, and runs it in testing mode.", UpdateFunc= funcact:
-            act.SetActiveStateUpdt(not ss.IsRunning)), win.This(), funcrecv, send, sig, data:
-            gi.StringPromptDialog(vp, "", "Test Item",
-                gi.DlgOpts(Title= "Test Item", Prompt= "Enter the Name of a given input pattern to test (case insensitive, contains given string."),
-                win.This(), funcrecv, send, sig, data:
-                    dlg = *gi.Dialog(send)
-                    if sig == int64(gi.DialogAccepted):
-                        val = gi.StringPromptDialogValue(dlg)
-                        idxs = ss.TestEnv.Table.RowsByString("Name", val, etable.Contains, etable.IgnoreCase)
-                        if len(idxs) == 0:
-                            gi.PromptDialog(nil, gi.DlgOpts(Title= "Name Not Found", Prompt= "No patterns found containing: " + val), gi.AddOk, gi.NoCancel, nil, nil)
-                        else:
-                            if not ss.IsRunning:
-                                ss.IsRunning = True
-                                print("testing index: %d\n" % idxs[0])
-                                ss.TestItem(idxs[0])
-                                ss.IsRunning = False
-                                vp.SetNeedsFullRender()))
-
-        tbar.AddAction(gi.ActOpts(Label= "Test All", Icon= "fast-fwd", Tooltip= "Tests all of the testing trials.", UpdateFunc= funcact:
-            act.SetActiveStateUpdt(not ss.IsRunning)), win.This(), funcrecv, send, sig, data:
-            if not ss.IsRunning:
-                ss.IsRunning = True
-                tbar.UpdateActions()
-                go ss.RunTestAll())
+        
+        tbar.AddAction(gi.ActOpts(Label="Test Trial", Icon="step-fwd", Tooltip="Runs the next testing trial.", UpdateFunc=UpdtFuncNotRunning), recv, TestTrialCB)
+        
+        tbar.AddAction(gi.ActOpts(Label="Test Item", Icon="step-fwd", Tooltip="Prompts for a specific input pattern name to run, and runs it in testing mode.", UpdateFunc=UpdtFuncNotRunning), recv, TestItemCB)
+        
+        tbar.AddAction(gi.ActOpts(Label="Test All", Icon="fast-fwd", Tooltip="Tests all of the testing trials.", UpdateFunc=UpdtFuncNotRunning), recv, TestAllCB)
 
         tbar.AddSeparator("log")
-
-        tbar.AddAction(gi.ActOpts(Label= "Reset RunLog", Icon= "reset", Tooltip= "Reset the accumulated log of all Runs, which are tagged with the ParamSet used"), win.This(),
-            funcrecv, send, sig, data:
-                ss.RunLog.SetNumRows(0)
-                ss.RunPlot.Update())
+        
+        tbar.AddAction(gi.ActOpts(Label="Reset RunLog", Icon="reset", Tooltip="Resets the accumulated log of all Runs, which are tagged with the ParamSet used"), recv, ResetRunLogCB)
 
         tbar.AddSeparator("misc")
+        
+        tbar.AddAction(gi.ActOpts(Label="New Seed", Icon="new", Tooltip="Generate a new initial random seed to get different results.  By default, Init re-establishes the same initial seed every time."), recv, NewRndSeedCB)
 
-        tbar.AddAction(gi.ActOpts(Label= "New Seed", Icon= "new", Tooltip= "Generate a new initial random seed to get different results.  By default, Init re-establishes the same initial seed every time."), win.This(),
-            funcrecv, send, sig, data:
-                ss.NewRndSeed())
-
-        tbar.AddAction(gi.ActOpts(Label= "README", Icon= "file-markdown", Tooltip= "Opens your browser on the README file that contains instructions for how to run this model."), win.This(),
-            funcrecv, send, sig, data:
-                gi.OpenURL("https://github.com/emer/leabra/blob/master/examples/ra25/README.md"))
-
-        vp.UpdateEndNoSig(updt)
+        tbar.AddAction(gi.ActOpts(Label="README", Icon="file-markdown", Tooltip="Opens your browser on the README file that contains instructions for how to run this model."), recv, ReadmeCB)
 
         # main menu
         appnm = gi.AppName()
         mmen = win.MainMenu
         mmen.ConfigMenus(go.Slice_string([appnm, "File", "Edit", "Window"]))
 
-        amen = *gi.Action(win.MainMenu.ChildByName(appnm, 0))
+        amen = gi.Action(win.MainMenu.ChildByName(appnm, 0))
         amen.Menu.AddAppMenu(win)
 
-        emen = *gi.Action(win.MainMenu.ChildByName("Edit", 1))
+        emen = gi.Action(win.MainMenu.ChildByName("Edit", 1))
         emen.Menu.AddCopyCutPaste(win)
 
         # note: Command in shortcuts is automatically translated into Control for
@@ -1259,125 +1256,82 @@
         #       win.Close()
         #   })
 
-        inQuitPrompt = False
-        gi.SetQuitReqFunc(func:
-            if inQuitPrompt:
-                return
-            inQuitPrompt = True
-            gi.PromptDialog(vp, gi.DlgOpts(Title= "Really Quit?",
-                Prompt= "Are you <i>sure</i> you want to quit and lose any unsaved params, weights, logs, etc?"), gi.AddOk, gi.AddCancel,
-                win.This(), funcrecv, send, sig, data:
-                    if sig == int64(gi.DialogAccepted):
-                        gi.Quit()
-                    else:
-                        inQuitPrompt = False))
-
-        # gi.SetQuitCleanFunc(func() {
-        #   print("Doing final Quit cleanup here..\n")
-        # })
-
-        inClosePrompt = False
-        win.SetCloseReqFunc(funcw:
-            if inClosePrompt:
-                return
-            inClosePrompt = True
-            gi.PromptDialog(vp, gi.DlgOpts(Title= "Really Close Window?",
-                Prompt= "Are you <i>sure</i> you want to close the window?  This will Quit the App as well, losing all unsaved params, weights, logs, etc"), gi.AddOk, gi.AddCancel,
-                win.This(), funcrecv, send, sig, data:
-                    if sig == int64(gi.DialogAccepted):
-                        gi.Quit()
-                    else:
-                        inClosePrompt = False))
-
-        win.SetCloseCleanFunc(funcw:
-            go gi.Quit())# once main window is closed, quit
-
         win.MainMenuUpdated()
-        return win
-
-    def CmdArgs(ss):
-        ss.NoGui = True
-        nogui
-        saveEpcLog
-        saveRunLog
-        note
-        flag.StringVar(ss.ParamSet, "params", "", "ParamSet name to use -- must be valid name as listed in compiled-in params or loaded params")
-        flag.StringVar(ss.Tag, "tag", "", "extra tag to add to file names saved from this run")
-        flag.StringVar(note, "note", "", "user note -- describe the run params etc")
-        flag.IntVar(ss.MaxRuns, "runs", 10, "number of runs to do (note that MaxEpcs is in paramset)")
-        flag.BoolVar(ss.LogSetParams, "setparams", False, "if true, print a record of each parameter that is set")
-        flag.BoolVar(ss.SaveWts, "wts", False, "if true, save final weights after each run")
-        flag.BoolVar(saveEpcLog, "epclog", True, "if true, save train epoch log to file")
-        flag.BoolVar(saveRunLog, "runlog", True, "if true, save run epoch log to file")
-        flag.BoolVar(nogui, "nogui", True, "if not passing any other args and want to run nogui, use nogui")
-        flag.Parse()
-        ss.Init()
-
-        if note != "":
-            print("note: %s\n" % note)
-        if ss.ParamSet != "":
-            print("Using ParamSet: %s\n" % ss.ParamSet)
-
-        if saveEpcLog:
-            err
-            fnm = ss.LogFileName("epc")
-            ss.TrnEpcFile, err = os.Create(fnm)
-            if err != nil:
-                log.Println(err)
-                ss.TrnEpcFile = nil
-            else:
-                print("Saving epoch log to: %s\n" % fnm)
-                defer ss.TrnEpcFile.Close()
-        if saveRunLog:
-            err
-            fnm = ss.LogFileName("run")
-            ss.RunFile, err = os.Create(fnm)
-            if err != nil:
-                log.Println(err)
-                ss.RunFile = nil
-            else:
-                print("Saving run log to: %s\n" % fnm)
-                defer ss.RunFile.Close()
-        if ss.SaveWts:
-            print("Saving final weights per run\n")
-        print("Running %d Runs\n" % ss.MaxRuns)
-        ss.Train()
-
+        vp.UpdateEndNoSig(updt)
+        win.GoStartEventLoop()
 
-# this registers this Sim Type and gives it properties that e.g.,
-# prompt for filename for save methods.
-KiT_Sim = kit.Types.AddType(Sim(), SimProps)
 
 # TheSim is the overall state for this simulation
-TheSim
-
-
-
-
-
-
-
-
-
-
-
-
+TheSim = Sim()
 
+def usage():
+    print(sys.argv[0] + " --params=<param set> --tag=<extra tag> --setparams --wts --epclog=0 --runlog=0 --nogui")
+    print("\t pyleabra -i %s to run in interactive, gui mode" % sys.argv[0])
+    print("\t --params=<param set> additional params to apply on top of Base (name must be in loaded Params")
+    print("\t --tag=<extra tag>    tag is appended to file names to uniquely identify this run") 
+    print("\t --runs=<n>           number of runs to do")
+    print("\t --setparams          show the parameter values that are set")
+    print("\t --wts                save final trained weights after every run")
+    print("\t --epclog=0/False     turn off save training epoch log data to file named by param set, tag")
+    print("\t --runlog=0/False     turn off save run log data to file named by param set, tag")
+    print("\t --nogui              if no other args needed, this prevents running under the gui")
 
+def main(argv):
+    TheSim.Config()
 
+    # print("n args: %d" % len(argv))
+    TheSim.NoGui = len(argv) > 1
+    saveEpcLog = True
+    saveRunLog = True
+        
+    try:
+        opts, args = getopt.getopt(argv,"h:",["params=","tag=","runs=","setparams","wts","epclog=","runlog=","nogui"])
+    except getopt.GetoptError:
+        usage()
+        sys.exit(2)
+    for opt, arg in opts:
+        # print("opt: %s  arg: %s" % (opt, arg))
+        if opt == '-h':
+            usage()
+            sys.exit()
+        elif opt == "--tag":
+            TheSim.Tag = arg
+        elif opt == "--runs":
+            TheSim.MaxRuns = int(arg)
+            print("Running %d runs" % TheSim.MaxRuns)
+        elif opt == "--setparams":
+            TheSim.LogSetParams = True
+        elif opt == "--wts":
+            TheSim.SaveWts = True
+            print("Saving final weights per run")
+        elif opt == "--epclog":
+            if arg.lower() == "false" or arg == "0":
+                saveEpcLog = False
+        elif opt == "--runlog":
+            if arg.lower() == "false" or arg == "0":
+                saveRunLog = False
+        elif opt == "--nogui":
+            TheSim.NoGui = True
 
-# These props register Save methods so they can be used
-SimProps = ki.Props(
-    "CallMethods"= ki.PropSlice(
-        ("SaveWeights", ki.Props(
-            "desc"= "save network weights to file",
-            "icon"= "file-save",
-            "Args"= ki.PropSlice(
-                ("File Name", ki.Props(
-                    "ext"= ".wts,.wts.gz",
-                )),
-            ),
-        )),
-    ),
-)
+    TheSim.Init()
+            
+    if TheSim.NoGui:
+        if saveEpcLog:
+            fnm = TheSim.LogFileName("epc") 
+            print("Saving epoch log to: %s" % fnm)
+            TheSim.TrnEpcFile = efile.Create(fnm)
+    
+        if saveRunLog:
+            fnm = TheSim.LogFileName("run") 
+            print("Saving run log to: %s" % fnm)
+            TheSim.RunFile = efile.Create(fnm)
+            
+        TheSim.Train()
+    else:
+        TheSim.ConfigGui()
+        print("Note: run pyleabra -i ra25.py to run in interactive mode, or just pyleabra, then 'import ra25'")
+        print("for non-gui background running, here are the args:")
+        usage()
+        
+main(sys.argv[1:])
 
